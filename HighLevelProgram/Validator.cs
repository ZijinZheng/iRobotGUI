using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace iRobotGUI
{
    public class Validator
    {
        public static bool Validate(String insStr)
        {
            Instruction ins;
            try
            {
                ins = new Instruction(insStr);
            }
            catch (InvalidOpcodeException ex)
            {
                throw ex;
            }

            switch (ins.opcode)
            {
                case Instruction.SONG_DEF:
                    return ValidateSongDef(ins);

                case Instruction.LOOP:
                    return CheckLoop(ins.opcode);

                case Instruction.END_LOOP:
                    return CheckLoop(ins.opcode);

                case Instruction.IF:
                    return CheckIf(ins.opcode);

                case Instruction.ELSE:
                    return CheckIf(ins.opcode);

                case Instruction.END_IF:
                    return CheckIf(ins.opcode);
            }
            return false;
        }

        // In fact, if a song is generated by GUI, there should not be any invalid ins.
        // Remove this function?
        public static bool ValidateSongDef(Instruction songIns)
        {
            int songLength = songIns.paramList.Count - 1;
            if (songLength < 2 || songLength>32) return false;

            int songNo = songIns.paramList[0];
            if ((songIns.paramList[0] < 0 || songIns.paramList[0] >15))
            {
                return false;
            }

            return true;

        }

        public static bool CheckIf(string opcode)
        {
            switch(opcode)
            {
                case Instruction.IF:
                    StackCheck.IfAmount++;
                    StackCheck.IfStack.Push(Instruction.IF);
                    break;

                case Instruction.ELSE:
                    StackCheck.ElseAmount++;
                    if (StackCheck.IfStack.Count == 0)
                        return false;
                    else if (StackCheck.IfStack.Peek() == Instruction.ELSE)
                        return false;
                    else
                    {
                        StackCheck.IfStack.Pop();
                        StackCheck.IfStack.Push(Instruction.ELSE);
                        break;
                    }

                case Instruction.END_IF:
                    StackCheck.EndIfAmount++;
                    if (StackCheck.IfStack.Count == 0)
                        return false;
                    else if (StackCheck.IfStack.Peek() == Instruction.IF)
                        return false;
                    else
                    {
                        StackCheck.IfStack.Pop();
                        break;
                    }
            }
            if ((StackCheck.IfStack.Count == 0)
                &&(StackCheck.IfAmount == StackCheck.ElseAmount)
                && (StackCheck.ElseAmount == StackCheck.EndIfAmount))
                return true;
            else
                return false;
        }

        public static bool CheckLoop(string opcode)
        {
            switch(opcode)
            {
                case Instruction.LOOP:
                    StackCheck.LoopStack.Push(Instruction.LOOP);
                    break;

                case Instruction.END_LOOP:
                    if (StackCheck.LoopStack.Count == 0)
                        return false;
                    else
                    {
                        StackCheck.LoopStack.Pop();
                        break;
                    }
            }
            if ((StackCheck.LoopStack.Count == 0) && (StackCheck.LoopAmount == StackCheck.EndLoopAmount))
                return true;
            else
                return false;
        }
    }


}
