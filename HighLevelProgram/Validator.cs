using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace iRobotGUI
{
	public class Validator
	{
		static private Stack<string> ifStack = new Stack<string>();
		static private Stack<string> loopStack = new Stack<string>();

		public static bool Validate(String insStr)
		{
			Instruction ins;
			try
			{
				ins = new Instruction(insStr);
			}
			catch (InvalidOpcodeException ex)
			{
				throw ex;
			}

			return Validate(ins);			
		}

		public static bool Validate(Instruction ins)
		{
			switch (ins.opcode)
			{
				case Instruction.SONG_DEF:
					return ValidateSongDef(ins);

				case Instruction.LOOP:
					return CheckLoop(ins.opcode);

				case Instruction.END_LOOP:
					return CheckLoop(ins.opcode);

				case Instruction.IF:
					return CheckIf(ins.opcode);

				case Instruction.ELSE:
					return CheckIf(ins.opcode);

				case Instruction.END_IF:
					return CheckIf(ins.opcode);
			}
			return false;
		}

		public static bool Validate(HLProgram program)
		{
			foreach (Instruction ins in program)
			{
				if (Validate(ins) == false) return false;
			}
			return true;
		}

		// In fact, if a song is generated by GUI, there should not be any invalid ins.
		// Remove this function?
		public static bool ValidateSongDef(Instruction songIns)
		{
			int songLength = songIns.paramList.Count - 1;
			if (songLength < 2 || songLength>32) return false;

			int songNo = songIns.paramList[0];
			if ((songIns.paramList[0] < 0 || songIns.paramList[0] >15))
			{
				return false;
			}

			return true;

		}

		public static bool CheckIf(string opcode)
		{
			string IF = Instruction.IF;
			string ELSE = Instruction.ELSE;
			string END_IF = Instruction.END_IF;

			string top = ifStack.Peek();

			if (opcode == IF)
			{
				ifStack.Push(opcode);
			}
			else if (opcode == ELSE)
			{
				if (top == IF) { ifStack.Pop(); ifStack.Push(opcode); }
				else return false;
			
			}
			else if (opcode == END_IF)
			{
				if (top == ELSE) { ifStack.Pop(); }
				else return false;
			}
			return true;		
	
		}

		public static bool CheckLoop(string opcode)
		{
			switch(opcode)
			{
				case Instruction.LOOP:
					StackCheck.LoopStack.Push(Instruction.LOOP);
					break;

				case Instruction.END_LOOP:
					if (StackCheck.LoopStack.Count == 0)
						return false;
					else
					{
						StackCheck.LoopStack.Pop();
						break;
					}
			}
			if ((StackCheck.LoopStack.Count == 0) && (StackCheck.LoopAmount == StackCheck.EndLoopAmount))
				return true;
			else
				return false;
		}
	}


}
